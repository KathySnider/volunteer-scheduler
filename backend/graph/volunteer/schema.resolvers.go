package volunteer

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"
	"volunteer-scheduler/graph/volunteer/generated"

	"github.com/lib/pq"
)

// EditVolunteerProfile
// Volunteers whose identities have been created by an admin
// may edit thier profiles as their lives change.
func (r *mutationResolver) EditVolunteerProfile(ctx context.Context, volunteerID string) (*generated.Volunteer, error) {
	panic(fmt.Errorf("not implemented: EditVolunteerProfile - editVolunteerProfile"))
}

// AssignVolunteerToShift
// Volunteers may assign themselves to a shift.
func (r *mutationResolver) AssignVolunteerToShift(ctx context.Context, shiftID string, volunteerID string) (*generated.AssignmentResult, error) {
	query := `
		INSERT INTO volunteer_shifts (volunteer_id, shift_id, assigned_at, status)
		VALUES ($1, $2, NOW(), 'confirmed')
		ON CONFLICT (volunteer_id, shift_id) DO NOTHING
	`

	_, err := r.DB.ExecContext(ctx, query, volunteerID, shiftID)
	if err != nil {
		return &generated.AssignmentResult{
			Success: false,
			Message: ptrString("Failed to assign volunteer to shift"),
		}, nil
	}

	return &generated.AssignmentResult{
		Success: true,
		Message: ptrString("Volunteer successfully assigned"),
	}, nil
}

// CancelShift
// TODO: Volunteers may cancel a shift assingment. Emails should
// be sent to alert the shift lead and/or volunteer coordinators
// if this occurs within xx days of the event.
func (r *mutationResolver) CancelShift(ctx context.Context, shiftID string, volunteerID string) (*generated.AssignmentResult, error) {
	panic(fmt.Errorf("not implemented: CancelShift - cancelShift"))
}

// Events
// Events can be filtered by city, role, type, date. If there is
// no filter, returns all events.
func (r *queryResolver) Events(ctx context.Context, filter *generated.EventFilter) ([]*generated.Event, error) {
	query := `
        SELECT DISTINCT
            e.event_id,
            e.event_name,
            e.description,
            e.event_is_virtual,
            e.location_id,
            l.location_name,
            l.street_address,
            l.city,
            l.state,
            l.zip_code
        FROM events e
        LEFT JOIN locations l ON e.location_id = l.location_id
        LEFT JOIN opportunities opp ON e.event_id = opp.event_id
        WHERE 1=1
    `

	args := []interface{}{}
	argCount := 1

	// Filter by cities.
	if filter != nil && len(filter.Cities) > 0 {
		placeholders := []string{}
		for _, city := range filter.Cities {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argCount))
			args = append(args, city)
			argCount++
		}
		query += fmt.Sprintf(" AND l.city IN (%s)", strings.Join(placeholders, ","))
	}

	// Filter by event type.
	if filter != nil && filter.EventType != nil {
		switch *filter.EventType {
		case "VIRTUAL":
			query += " AND e.event_is_virtual = true AND e.location_id IS NULL"
		case "IN_PERSON":
			query += " AND e.event_is_virtual = false"
		case "HYBRID":
			query += " AND e.event_is_virtual = true AND e.location_id IS NOT NULL"
		}
	}

	// Filter by roles.
	if filter != nil && len(filter.Roles) > 0 {
		placeholders := []string{}
		for _, role := range filter.Roles {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argCount))
			dbRole := strings.ToLower(string(role))
			args = append(args, dbRole)
			argCount++
		}
		query += fmt.Sprintf(" AND opp.role IN (%s)", strings.Join(placeholders, ","))
	}

	// Filter by date range.
	if filter != nil && (filter.StartDate != nil || filter.EndDate != nil) {
		query = strings.Replace(query, "WHERE 1=1",
			"LEFT JOIN opportunities opp2 ON e.event_id = opp2.event_id "+
				"LEFT JOIN shifts s_filter ON opp2.opportunity_id = s_filter.opportunity_id "+
				"WHERE 1=1", 1)

		if filter.StartDate != nil {
			query += fmt.Sprintf(" AND s_filter.shift_start >= $%d", argCount)
			args = append(args, *filter.StartDate)
			argCount++
		}
		if filter.EndDate != nil {
			query += fmt.Sprintf(" AND s_filter.shift_start <= $%d", argCount)
			args = append(args, *filter.EndDate)
			argCount++
		}
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying events: %w", err)
	}
	defer rows.Close()

	// Now we have selected the events that meet all of the user's
	// criteria. Process each one to see if there are volunteer
	// opportunities with open shifts that also meet their criteria.
	eventsMap := make(map[string]*generated.Event)

	for rows.Next() {
		var e generated.Event
		var loc generated.Venue
		var locationID *int
		var locationName, address, city, state, zipCode *string

		var eventInt int
		var eventStr string
		var isVirtual bool // Temporary variable for database value

		err := rows.Scan(
			&eventInt,
			&e.Name,
			&e.Description,
			&isVirtual,
			&locationID,
			&locationName,
			&address,
			&city,
			&state,
			&zipCode,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning event: %w", err)
		}

		eventStr = fmt.Sprintf("%d", eventInt) // string for GraphQL.
		e.ID = eventStr

		// Determine if event is virtual, in person, or both.
		if isVirtual && locationID != nil {
			e.EventType = "HYBRID"
		} else if isVirtual {
			e.EventType = "VIRTUAL"
		} else {
			e.EventType = "IN_PERSON"
		}

		// Check if we've already processed this event.
		if _, exists := eventsMap[eventStr]; !exists {
			// Add location if it exists.
			if locationID != nil && address != nil && city != nil && state != nil {
				loc.Name = locationName
				loc.Address = *address
				loc.City = *city
				loc.State = *state
				loc.ZipCode = zipCode
				e.Venue = &loc
			}

			eventsMap[eventStr] = &e
		}
	}

	// Now fetch shifts for these events.
	if len(eventsMap) > 0 {
		eventIDs := []string{}
		for id := range eventsMap {
			eventIDs = append(eventIDs, id)
		}

		shiftsQuery := `
            SELECT
                s.shift_id,
                s.shift_start,
                s.shift_end,
                opp.role,
                opp.event_id
            FROM shifts s
            JOIN opportunities opp ON s.opportunity_id = opp.opportunity_id
            WHERE opp.event_id = ANY($1)
        `

		shiftArgs := []interface{}{pq.Array(eventIDs)}
		argNum := 2

		// Filter shifts by dates.
		if filter != nil && filter.StartDate != nil {
			shiftsQuery += fmt.Sprintf(" AND s.shift_start >= $%d", argNum)
			shiftArgs = append(shiftArgs, *filter.StartDate)
			argNum++
		}
		if filter != nil && filter.EndDate != nil {
			shiftsQuery += fmt.Sprintf(" AND s.shift_start <= $%d", argNum)
			shiftArgs = append(shiftArgs, *filter.EndDate)
			argNum++
		}

		// Filter by role.
		if filter != nil && len(filter.Roles) > 0 {
			placeholders := []string{}
			for _, role := range filter.Roles {
				placeholders = append(placeholders, fmt.Sprintf("$%d", argNum))
				dbRole := strings.ToLower(string(role))
				shiftArgs = append(shiftArgs, dbRole)
				argNum++
			}
			shiftsQuery += fmt.Sprintf(" AND opp.role IN (%s)", strings.Join(placeholders, ","))
		}

		shiftRows, err := r.DB.QueryContext(ctx, shiftsQuery, shiftArgs...)
		if err != nil {
			return nil, fmt.Errorf("error querying shifts: %w", err)
		}
		defer shiftRows.Close()

		// We are left with events that have open shifts that match all
		// criteria. Do some formatting.
		for shiftRows.Next() {
			var shift generated.Shift
			var eventInt int
			var eventStr string
			var startTime, endTime time.Time
			var role string
			var shiftInt int

			err := shiftRows.Scan(
				&shiftInt,
				&startTime,
				&endTime,
				&role,
				&eventInt,
			)
			if err != nil {
				return nil, fmt.Errorf("error scanning shift: %w", err)
			}

			eventStr = fmt.Sprintf("%d", eventInt) // string for GraphQL.

			// Format the timestamps.
			shift.Date = startTime.Format("2006-01-02")
			shift.StartTime = startTime.Format("15:04:05")
			shift.EndTime = endTime.Format("15:04:05")

			// Convert role string to Role enum.
			shift.Role = generated.Role(strings.ToUpper(role))

			if event, exists := eventsMap[eventStr]; exists {
				event.Shifts = append(event.Shifts, &shift)
			}
		}
	}

	// Convert map to slice
	events := make([]*generated.Event, 0, len(eventsMap))
	for _, event := range eventsMap {
		events = append(events, event)
	}

	return events, nil
}

// EventByID
// Returns the details for an event, including shifts.
func (r *queryResolver) EventByID(ctx context.Context, id string) (*generated.Event, error) {
	query := `
		SELECT 
			e.event_id,
			e.event_name,
			e.description,
			e.event_is_virtual,
			e.location_id,
			l.location_name,
			l.street_address,
			l.city,
			l.state,
			l.zip_code
		FROM events e
		LEFT JOIN locations l ON e.location_id = l.location_id
		WHERE e.event_id = $1
	`

	var event generated.Event
	var eventID int
	var isVirtual bool
	var locationID *int
	var locationName, address, city, state, zipCode *string

	err := r.DB.QueryRowContext(ctx, query, id).Scan(
		&eventID,
		&event.Name,
		&event.Description,
		&isVirtual,
		&locationID,
		&locationName,
		&address,
		&city,
		&state,
		&zipCode,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("event not found")
	}
	if err != nil {
		return nil, fmt.Errorf("error querying event: %w", err)
	}

	event.ID = fmt.Sprintf("%d", eventID) // string for GraphQl

	// Determine if the event is virtual, in person, or either (hybrid).
	if isVirtual && locationID != nil {
		event.EventType = "HYBRID"
	} else if isVirtual {
		event.EventType = "VIRTUAL"
	} else {
		event.EventType = "IN_PERSON"
	}

	// Add location if it exists.
	if locationID != nil && address != nil && city != nil && state != nil {
		venue := &generated.Venue{
			Name:    locationName,
			Address: *address,
			City:    *city,
			State:   *state,
			ZipCode: zipCode,
		}
		event.Venue = venue
	}

	// Fetch opportunities for this event
	opportunities, err := r.getOpportunitiesForEvent(ctx, eventID)
	if err != nil {
		return nil, err
	}
	event.Opportunities = opportunities

	return &event, nil
}

// VolunteerProfile is the resolver for the volunteerProfile field.
func (r *queryResolver) VolunteerProfile(ctx context.Context, volunteerID string) (*generated.Volunteer, error) {
	panic(fmt.Errorf("not implemented: VolunteerProfile - volunteerProfile"))
}

// AllVolunteers is the resolver for the allVolunteers field.
func (r *queryResolver) AllVolunteers(ctx context.Context, filter *generated.VolunteerFilter) ([]*generated.Volunteer, error) {
	var query string
	var args []interface{}

	// Get all volunteers for now.
	// We may need a filter here, so it's in the input, but
	// we'll deal with that when we know if we are looking 
	// up by email or name or ??
	query = `
		SELECT volunteer_id, first_name, last_name
		FROM volunteers
	`

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying volunteers: %w", err)
	}
	defer rows.Close()

	var volunteers []*generated.Volunteer
	for rows.Next() {
		var v generated.Volunteer
		var volunteerID int

		err := rows.Scan(&volunteerID, &v.FirstName, &v.LastName)
		if err != nil {
			return nil, fmt.Errorf("error scanning volunteer: %w", err)
		}

		v.ID = fmt.Sprintf("%d", volunteerID)
		volunteers = append(volunteers, &v)
	}

	return volunteers, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
