package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"
	"vol_sched_api/graph/model"

	"github.com/lib/pq"
)

// CreateVolunteer is the resolver for the createVolunteer field.
func (r *mutationResolver) CreateVolunteer(ctx context.Context, firstName string, lastName string) (*model.Volunteer, error) {
	query := `
		INSERT INTO volunteers (first_name, last_name, created_at)
		VALUES ($1, $2, NOW())
		RETURNING volunteer_id
	`

	var volunteerID int
	err := r.DB.QueryRowContext(ctx, query, firstName, lastName).Scan(&volunteerID)
	if err != nil {
		return nil, fmt.Errorf("error creating volunteer: %w", err)
	}

	return &model.Volunteer{
		ID:        fmt.Sprintf("%d", volunteerID),
		FirstName: firstName,
		LastName:  lastName,
	}, nil
}

// AssignVolunteerToShift is the resolver for the assignVolunteerToShift field.
func (r *mutationResolver) AssignVolunteerToShift(ctx context.Context, shiftID string, volunteerID string) (*model.AssignmentResult, error) {
	query := `
		INSERT INTO volunteer_shifts (volunteer_id, shift_id, assigned_at, status)
		VALUES ($1, $2, NOW(), 'confirmed')
		ON CONFLICT (volunteer_id, shift_id) DO NOTHING
	`

	_, err := r.DB.ExecContext(ctx, query, volunteerID, shiftID)
	if err != nil {
		return &model.AssignmentResult{
			Success: false,
			Message: ptrString("Failed to assign volunteer to shift"),
		}, nil
	}

	return &model.AssignmentResult{
		Success: true,
		Message: ptrString("Volunteer successfully assigned"),
	}, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, name string, description *string, eventType model.EventType, locationName *string) (*model.Event, error) {
	return nil, fmt.Errorf("error creating event: not yet implemented")
	//panic(fmt.Errorf("not implemented: CreateEvent - createEvent"))
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, filter *model.EventFilter) ([]*model.Event, error) {
	query := `
        SELECT DISTINCT
            e.event_id,
            e.event_name,
            e.description,
            e.event_is_virtual,
            e.location_id,
            l.location_name,
            l.street_address,
            l.city,
            l.state,
            l.zip_code
        FROM events e
        LEFT JOIN locations l ON e.location_id = l.location_id
        LEFT JOIN opportunities opp ON e.event_id = opp.event_id
        WHERE 1=1
    `

	args := []interface{}{}
	argCount := 1

	// Filter by cities.
	if filter != nil && len(filter.Cities) > 0 {
		placeholders := []string{}
		for _, city := range filter.Cities {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argCount))
			args = append(args, city)
			argCount++
		}
		query += fmt.Sprintf(" AND l.city IN (%s)", strings.Join(placeholders, ","))
	}

	// Filter by event type.
	if filter != nil && filter.EventType != nil {
		switch *filter.EventType {
		case "VIRTUAL":
			query += " AND e.event_is_virtual = true AND e.location_id IS NULL"
		case "IN_PERSON":
			query += " AND e.event_is_virtual = false"
		case "HYBRID":
			query += " AND e.event_is_virtual = true AND e.location_id IS NOT NULL"
		}
	}

	// Filter by roles.
	if filter != nil && len(filter.Roles) > 0 {
		placeholders := []string{}
		for _, role := range filter.Roles {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argCount))
			dbRole := strings.ToLower(string(role))
			args = append(args, dbRole)
			argCount++
		}
		query += fmt.Sprintf(" AND opp.role IN (%s)", strings.Join(placeholders, ","))
	}

	// Filter by date range.
	if filter != nil && (filter.StartDate != nil || filter.EndDate != nil) {
		query = strings.Replace(query, "WHERE 1=1",
			"LEFT JOIN opportunities opp2 ON e.event_id = opp2.event_id "+
				"LEFT JOIN shifts s_filter ON opp2.opportunity_id = s_filter.opportunity_id "+
				"WHERE 1=1", 1)

		if filter.StartDate != nil {
			query += fmt.Sprintf(" AND s_filter.shift_start >= $%d", argCount)
			args = append(args, *filter.StartDate)
			argCount++
		}
		if filter.EndDate != nil {
			query += fmt.Sprintf(" AND s_filter.shift_start <= $%d", argCount)
			args = append(args, *filter.EndDate)
			argCount++
		}
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying events: %w", err)
	}
	defer rows.Close()

	// Now we have selected the events that meet all of the user's
	// criteria. Process each one to see if there are volunteer
	// opportunities with open shifts that also meet their criteria.
	eventsMap := make(map[string]*model.Event)

	for rows.Next() {
		var e model.Event
		var loc model.Location
		var locationID *int
		var locationName, address, city, state, zipCode *string

		var eventInt int
		var eventStr string
		var isVirtual bool // Temporary variable for database value

		err := rows.Scan(
			&eventInt,
			&e.Name,
			&e.Description,
			&isVirtual,
			&locationID,
			&locationName,
			&address,
			&city,
			&state,
			&zipCode,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning event: %w", err)
		}

		eventStr = fmt.Sprintf("%d", eventInt) // string for GraphQL.
		e.ID = eventStr

		// Determine if event is virtual, in person, or both.
		if isVirtual && locationID != nil {
			e.EventType = "HYBRID"
		} else if isVirtual {
			e.EventType = "VIRTUAL"
		} else {
			e.EventType = "IN_PERSON"
		}

		// Check if we've already processed this event.
		if _, exists := eventsMap[eventStr]; !exists {
			// Add location if it exists.
			if locationID != nil && address != nil && city != nil && state != nil {
				loc.Name = locationName
				loc.Address = *address
				loc.City = *city
				loc.State = *state
				loc.ZipCode = zipCode
				e.Location = &loc
			}

			eventsMap[eventStr] = &e
		}
	}

	// Now fetch shifts for these events.
	if len(eventsMap) > 0 {
		eventIDs := []string{}
		for id := range eventsMap {
			eventIDs = append(eventIDs, id)
		}

		shiftsQuery := `
            SELECT 
                s.shift_id,
                s.shift_start,
                s.shift_end,
                opp.role,
                opp.event_id
            FROM shifts s
            JOIN opportunities opp ON s.opportunity_id = opp.opportunity_id
            WHERE opp.event_id = ANY($1)
        `

		shiftArgs := []interface{}{pq.Array(eventIDs)}
		argNum := 2

		// Filter shifts by dates.
		if filter != nil && filter.StartDate != nil {
			shiftsQuery += fmt.Sprintf(" AND s.shift_start >= $%d", argNum)
			shiftArgs = append(shiftArgs, *filter.StartDate)
			argNum++
		}
		if filter != nil && filter.EndDate != nil {
			shiftsQuery += fmt.Sprintf(" AND s.shift_start <= $%d", argNum)
			shiftArgs = append(shiftArgs, *filter.EndDate)
			argNum++
		}

		// Filter by role.
		if filter != nil && len(filter.Roles) > 0 {
			placeholders := []string{}
			for _, role := range filter.Roles {
				placeholders = append(placeholders, fmt.Sprintf("$%d", argNum))
				dbRole := strings.ToLower(string(role))
				shiftArgs = append(shiftArgs, dbRole)
				argNum++
			}
			shiftsQuery += fmt.Sprintf(" AND opp.role IN (%s)", strings.Join(placeholders, ","))
		}

		shiftRows, err := r.DB.QueryContext(ctx, shiftsQuery, shiftArgs...)
		if err != nil {
			return nil, fmt.Errorf("error querying shifts: %w", err)
		}
		defer shiftRows.Close()

		// We are left with events that have open shifts that match all
		// criteria. Do some formatting.
		for shiftRows.Next() {
			var shift model.Shift
			var eventInt int
			var eventStr string
			var startTime, endTime time.Time
			var role string
			var shiftInt int

			err := shiftRows.Scan(
				&shiftInt,
				&startTime,
				&endTime,
				&role,
				&eventInt,
			)
			if err != nil {
				return nil, fmt.Errorf("error scanning shift: %w", err)
			}

			eventStr = fmt.Sprintf("%d", eventInt) // string for GraphQL.

			// Format the timestamps.
			shift.Date = startTime.Format("2006-01-02")
			shift.StartTime = startTime.Format("15:04:05")
			shift.EndTime = endTime.Format("15:04:05")

			// Convert role string to RoleType enum.
			shift.Role = model.RoleType(strings.ToUpper(role))

			if event, exists := eventsMap[eventStr]; exists {
				event.Shifts = append(event.Shifts, &shift)
			}
		}
	}

	// Convert map to slice
	events := make([]*model.Event, 0, len(eventsMap))
	for _, event := range eventsMap {
		events = append(events, event)
	}

	return events, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.Event, error) {
	query := `
		SELECT 
			e.event_id,
			e.event_name,
			e.description,
			e.event_is_virtual,
			e.location_id,
			l.location_name,
			l.street_address,
			l.city,
			l.state,
			l.zip_code
		FROM events e
		LEFT JOIN locations l ON e.location_id = l.location_id
		WHERE e.event_id = $1
	`

	var event model.Event
	var eventID int
	var isVirtual bool
	var locationID *int
	var locationName, address, city, state, zipCode *string

	err := r.DB.QueryRowContext(ctx, query, id).Scan(
		&eventID,
		&event.Name,
		&event.Description,
		&isVirtual,
		&locationID,
		&locationName,
		&address,
		&city,
		&state,
		&zipCode,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("event not found")
	}
	if err != nil {
		return nil, fmt.Errorf("error querying event: %w", err)
	}

	event.ID = fmt.Sprintf("%d", eventID) // string for GraphQl

	// Determine if the event is virtual, in person, or either (hybrid).
	if isVirtual && locationID != nil {
		event.EventType = "HYBRID"
	} else if isVirtual {
		event.EventType = "VIRTUAL"
	} else {
		event.EventType = "IN_PERSON"
	}

	// Add location if it exists.
	if locationID != nil && address != nil && city != nil && state != nil {
		loc := &model.Location{
			Name:    locationName,
			Address: *address,
			City:    *city,
			State:   *state,
			ZipCode: zipCode,
		}
		event.Location = loc
	}

	// Fetch opportunities for this event
	opportunities, err := r.getOpportunitiesForEvent(ctx, eventID)
	if err != nil {
		return nil, err
	}
	event.Opportunities = opportunities

	return &event, nil
}

// Volunteers is the resolver for the volunteers field.
func (r *queryResolver) Volunteers(ctx context.Context, qualifications []string) ([]*model.Volunteer, error) {
	var query string
	var args []interface{}

	if len(qualifications) > 0 {
		// Filter by qualifications
		query = `
			SELECT DISTINCT v.volunteer_id, v.first_name, v.last_name
			FROM volunteers v
			JOIN volunteer_qualifications vq ON v.volunteer_id = vq.volunteer_id
			WHERE vq.qualification = ANY($1)
		`
		args = append(args, pq.Array(qualifications))
	} else {
		// Get all volunteers
		query = `
			SELECT volunteer_id, first_name, last_name
			FROM volunteers
		`
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying volunteers: %w", err)
	}
	defer rows.Close()

	var volunteers []*model.Volunteer
	for rows.Next() {
		var v model.Volunteer
		var volunteerID int

		err := rows.Scan(&volunteerID, &v.FirstName, &v.LastName)
		if err != nil {
			return nil, fmt.Errorf("error scanning volunteer: %w", err)
		}

		v.ID = fmt.Sprintf("%d", volunteerID)
		volunteers = append(volunteers, &v)
	}

	return volunteers, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
